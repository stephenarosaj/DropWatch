<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>sqliteDB.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">s0</a> &gt; <a href="index.source.html" class="el_package">edu.brown.cs.student.api.database</a> &gt; <span class="el_source">sqliteDB.java</span></div><h1>sqliteDB.java</h1><pre class="source lang-java linenums">package edu.brown.cs.student.api.database;

import java.io.File;
import java.sql.*;
import java.util.ArrayList;
import java.util.Objects;
import org.testng.internal.collections.Pair;

/**
 * A class for connecting to and interacting with an sqlite3 database. This class uses the JDBC
 * (Java DataBase Controller) library with an sqlite3 driver (because I &lt;3 sqlite3). My
 * understanding is that JDBC is like the VFS (Virtual File System) and sqlite3 is like S5FS (a
 * filesystem), if that makes sense to you, reader.
 * ----------------------------------------------------------------------------- JDBC Driver
 * Documentation: &lt;a
 * href=&quot;https://www.sqlite.org/java/raw/doc/overview.html?name=0a704f4b7294a3d63e6ea2b612daa3b997c4b5f1&quot;&gt;...&lt;/a&gt;
 * sqliteTutorial Documentation (lots of source material from here): &lt;a
 * href=&quot;https://www.sqlitetutorial.net/sqlite-java/&quot;&gt;...&lt;/a&gt;
 * ----------------------------------------------------------------------------- NOTES: - &quot;the only
 * data types supported on SQLite tables are java.lang.String, short, int, float, and double&quot; -
 * connecting to a DB that does not exist will NOT create a new DB (typically it does, but this
 * functionality is suppressed by this class) - almost (ALMOST) none of these methods throw
 * exceptions. instead, they print to stdout. exceptions to this rule are: - tableExists(): this
 * method returns true/false indicating if the table exists. if its existence cannot be determined,
 * an exception is thrown. - autoCommit is on by default!
 */
public class sqliteDB {
  /** The Connection to our database */
  private Connection conn;

  /** Relative filepath of our database */
  private String relativeFilepath;

  /** Constructor for a Database object! */
  public sqliteDB() {
    this.conn = null;
    this.relativeFilepath = null;
  }

  /** Get defensive copy of relativeFilepath */
<span class="fc" id="L41">  public String copyRelativeFilepath() {</span>
<span class="fc" id="L42">    if (this.relativeFilepath == null) {</span>
<span class="fc" id="L43">      return null;</span>
<span class="fc" id="L44">    } else {</span>
      return new String(this.relativeFilepath);
    }
  }

  /**
<span class="fc bfc" id="L50" title="All 2 branches covered.">   * method to check that we have the org.sqlite.JDBC class, indicating that our JDBC is configured</span>
<span class="fc" id="L51">   * properly. returns nothing, but throws exception if we don't have the class</span>
   *
<span class="fc" id="L53">   * @throws ClassNotFoundException if we don't have the org.sqlite.JDBC class</span>
   */
  private void checkForSqliteDriver() throws ClassNotFoundException {
    // check if we have an org.sqlite.JDBC class
    // (throws ClassNotFoundException if no)
    Class.forName(&quot;org.sqlite.JDBC&quot;);
  }

  /**
   * method to check if this.conn is null. returns boolean indicating if null
   *
   * @return boolean indicating if this.conn == null
   */
  public boolean connIsNull() {
<span class="fc" id="L67">    // verify that we actually have a conn</span>
<span class="fc" id="L68">    return this.conn == null;</span>
  }

  /**
   * Method for committing manually. When used, commits staged changes to the DB
   *
   * @return boolean indicating success of commit
   * @throws ClassNotFoundException if could not load SQLite JDBC driver
   * @throws SQLException if could not successfully commit
<span class="fc bfc" id="L77" title="All 2 branches covered.">   */</span>
  public boolean commit() throws ClassNotFoundException, SQLException {
    try {
      // check if we have an org.sqlite.JDBC class
      // (throws ClassNotFoundException if no)
      this.checkForSqliteDriver();

      // verify that we actually have a conn
      // (throw exception if no)
      if (this.connIsNull()) {
        throw new SQLException(&quot;this.conn == null&quot;);
      }

      // commit!
      this.conn.commit();
<span class="fc" id="L92"></span>
      // return success!
      System.out.println(&quot;Success! Committed to DB!&quot;);
      return true;
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">    } catch (SQLException e) {</span>
<span class="nc" id="L97">      // error committing!</span>
      throw new SQLException(&quot;ERROR: Couldn't this.conn.commit():\n&quot; + e.getMessage());
    } catch (ClassNotFoundException e) {
      // error! we don't have an org.sqlite.JDBC class!
<span class="fc" id="L101">      throw new ClassNotFoundException(</span>
          &quot;ERROR: Could not load SQLite JDBC driver:\n&quot; + e.getMessage());
    }
<span class="fc" id="L104">  }</span>
<span class="fc" id="L105"></span>
<span class="nc" id="L106">  /**</span>
   * Method for setting autocommit. If true, after each statement executed, the database will commit
<span class="nc" id="L108">   * automatically</span>
<span class="nc" id="L109">   *</span>
   * @return a boolean indicating success of setting autocommit
<span class="nc" id="L111">   * @throws ClassNotFoundException if could not load SQLite JDBC driver</span>
   * @throws SQLException if could not successfully setAutoCommit
   */
  public boolean setAutoCommit(boolean bool) throws ClassNotFoundException, SQLException {
    try {
      // check if we have an org.sqlite.JDBC class
      // (throws ClassNotFoundException if no)
      this.checkForSqliteDriver();

      // verify that we actually have a conn
      // (throw exception if no)
      if (this.connIsNull()) {
        throw new SQLException(&quot;this.conn == null&quot;);
      }

      // set autocommit!
      this.conn.setAutoCommit(bool);
<span class="fc" id="L128"></span>
      // return success!
      System.out.println(&quot;Success! AutoCommit successfully changed for this.conn!&quot;);
      return true;
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">    } catch (SQLException e) {</span>
<span class="nc" id="L133">      // error commiting!</span>
      throw new SQLException(
          &quot;ERROR: Couldn't this.conn.setAutoCommit(&quot;
              + (bool ? &quot;TRUE&quot; : &quot;FALSE&quot;)
<span class="fc" id="L137">              + &quot;):\n&quot;</span>
              + e.getMessage());
    } catch (ClassNotFoundException e) {
<span class="fc" id="L140">      // error! we don't have an org.sqlite.JDBC class!</span>
<span class="fc" id="L141">      throw new ClassNotFoundException(</span>
<span class="nc" id="L142">          &quot;ERROR: Could not load SQLite JDBC driver:\n&quot; + e.getMessage());</span>
    }
<span class="nc bnc" id="L144" title="All 2 branches missed.">  }</span>
<span class="nc" id="L145"></span>
  /**
<span class="nc" id="L147">   * Create a new database file with a chosen filepath, returning boolean indicating success. Also</span>
   * updates this.conn on success NOTE: connecting to a database that does not exist CREATES A NEW
   * DATABASE! This method is used to deliberately connect to a database that does not exist, and
   * therefore this method checks to see if the database exists before connecting, and if it DOES
   * exist, it does not connect. If you want to connect to a DB that already exists, use
   * Database.connectDB()!
   * ----------------------------------------------------------------------------- Source material:
   * &lt;a href=&quot;https://www.sqlitetutorial.net/sqlite-java/create-database/&quot;&gt;...&lt;/a&gt;
   * -----------------------------------------------------------------------------
   *
   * @param relativeFilepath the filepath of the DB to be created
   * @return a boolean indicating success of creation
   * @throws ClassNotFoundException if could not load SQLite JDBC driver
   * @throws SQLException if could not successfully create SQLiteDB
   */
  public boolean createDB(String relativeFilepath) throws ClassNotFoundException, SQLException {
    try {
      // check if we have an org.sqlite.JDBC class
      // (throws ClassNotFoundException if no)
      checkForSqliteDriver();

      // conn represents our connection to the database itself
      Connection conn = null;

      // check if database already exists
      File f = new File(relativeFilepath);
      if (f.exists()) {
<span class="fc" id="L174">        // if it already exists, throw error. We don't want to connect to an</span>
        // existing database, we want to create a new one!
        throw new SQLException(&quot;database '&quot; + relativeFilepath + &quot;' already exists!&quot;);
<span class="fc" id="L177">      }</span>

      // calculate path to db (adding &quot;jdbc:sqlite:&quot; is required by the library)
<span class="fc" id="L180">      String url = &quot;jdbc:sqlite:&quot; + relativeFilepath;</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">      // create a connection to the database</span>
      // (throws SQLException if can't connect to DB)
      conn = DriverManager.getConnection(url);
<span class="fc" id="L184">      // update this.conn and this.relativeFilepath</span>
      this.conn = conn;
      this.relativeFilepath = relativeFilepath;
      this.setAutoCommit(false);
<span class="fc" id="L188"></span>
      // success!
      System.out.println(&quot;Success! New SQLite DB has been created&quot;);
<span class="fc" id="L191">      return true;</span>
    } catch (SQLException e) {
<span class="fc" id="L193">      // error creating the SQLiteDB!</span>
<span class="fc" id="L194">      throw new SQLException(&quot;ERROR: new SQLiteDB could not be created\n:&quot; + e.getMessage());</span>
<span class="fc" id="L195">    } catch (ClassNotFoundException e) {</span>
      // error! we don't have an org.sqlite.JDBC class!
      throw new ClassNotFoundException(
<span class="fc" id="L198">          &quot;ERROR: Could not load SQLite JDBC driver:\n&quot; + e.getMessage());</span>
<span class="fc" id="L199">    }</span>
<span class="fc" id="L200">  }</span>

<span class="fc" id="L202">  /**</span>
<span class="nc" id="L203">   * Connect to a database specified by filepath, returning boolean indicating success. Also updates</span>
   * this.conn on success NOTE: connecting to a database that does not exist CREATES A NEW DATABASE!
<span class="nc" id="L205">   * Therefore, this method checks to see if the database exists before connecting, and if it DOES</span>
   * NOT exist, it does not connect (it does not create a new database). If you want to create a new
   * database, use Database.createDB()!
   * ----------------------------------------------------------------------------- Source material:
   * &lt;a href=&quot;https://www.sqlitetutorial.net/sqlite-java/sqlite-jdbc-driver/&quot;&gt;...&lt;/a&gt;
   * -----------------------------------------------------------------------------
   *
   * @param relativeFilepath the relative filepath of the database, relative to the project root
   * @return a boolean indicating if we could connect or not
   * @throws ClassNotFoundException if could not load SQLite JDBC driver
   * @throws SQLException if could not successfully connect to SQLiteDB
   */
  public boolean connectDB(String relativeFilepath) throws ClassNotFoundException, SQLException {
    try {
      // check if we have an org.sqlite.JDBC class
      // (throws ClassNotFoundException if no)
      checkForSqliteDriver();

      // check if database already exists
      File f = new File(relativeFilepath);
      if (!f.exists()) {
        // if it already exists, throw error. We don't want to create a new database,
        // we want to connect to an existing one!
        throw new SQLException(
            &quot;SQLiteDB '&quot;
                + System.getProperty(&quot;user.dir&quot;)
<span class="fc" id="L231">                + &quot;/&quot;</span>
                + relativeFilepath
                + &quot;' does not exist!&quot;);
<span class="fc" id="L234">      }</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed."></span>
      // verify that we DO NOT have a conn
      // (throw exception if yes)
<span class="nc" id="L238">      if (!this.connIsNull()) {</span>
        throw new SQLException(
            &quot;Already connected to another database '&quot;
                + System.getProperty(&quot;user.dir&quot;)
                + &quot;/&quot;
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">                + this.relativeFilepath</span>
<span class="nc" id="L244">                + &quot;',&quot;</span>
                + &quot;must disconnect with sqliteDB.close() before connecting to new database!&quot;);
      }

      // calculate path to db (adding &quot;jdbc:sqlite:&quot; is required by the library)
<span class="fc" id="L249">      String url = &quot;jdbc:sqlite:&quot; + relativeFilepath;</span>
      // create a connection to the database
      // (throws SQLException if can't connect to DB)
<span class="fc" id="L252">      this.conn = DriverManager.getConnection(url);</span>
      ;
<span class="fc" id="L254">      // update filepath and this.conn</span>
      this.relativeFilepath = relativeFilepath;
<span class="fc" id="L256">      // set autocommit to false</span>
      this.setAutoCommit(false);

      // success!
<span class="fc" id="L260">      System.out.println(&quot;Success! Connection to SSQLiteDB has been established&quot;);</span>
<span class="fc" id="L261">      return true;</span>
<span class="nc" id="L262">    } catch (SQLException e) {</span>
      // error connecting to the SQLiteDB!
<span class="nc" id="L264">      throw new SQLException(</span>
<span class="nc" id="L265">          &quot;ERROR: Connection to SQLiteDB could not be established:\n&quot; + e.getMessage());</span>
    } catch (ClassNotFoundException e) {
<span class="nc" id="L267">      // error! we don't have an org.sqlite.JDBC class!</span>
      throw new ClassNotFoundException(
          &quot;ERROR: Could not load SQLite JDBC driver:\n&quot; + e.getMessage());
    }
  }

  /**
   * Function to close this.conn
   *
   * @return boolean indicating success of closure
   * @throws ClassNotFoundException if could not load SQLite JDBC driver
   * @throws SQLException if could not successfully close SQLiteDB
   */
  public boolean closeDB() throws ClassNotFoundException, SQLException {
    // try to close this.conn!
    try {
      // check if we have an org.sqlite.JDBC class
<span class="fc" id="L284">      // (throws ClassNotFoundException if no)</span>
      this.checkForSqliteDriver();

      // verify that we actually have a conn
<span class="fc bfc" id="L288" title="All 2 branches covered.">      // (throw exception if no)</span>
<span class="fc" id="L289">      if (this.connIsNull()) {</span>
        throw new SQLException(&quot;this.conn == null&quot;);
      }

<span class="fc" id="L293">      // close, set this.conn to null</span>
<span class="fc" id="L294">      this.conn.close();</span>
<span class="fc" id="L295">      this.conn = null;</span>
      this.relativeFilepath = null;

<span class="fc" id="L298">      // return success!</span>
<span class="fc" id="L299">      System.out.println(&quot;Success! Connection to SSQLiteDB has been closed&quot;);</span>
<span class="fc" id="L300">      return true;</span>
    } catch (SQLException e) {
<span class="fc" id="L302">      // error closing connection!</span>
<span class="nc" id="L303">      throw new SQLException(</span>
          &quot;ERROR: Connection to SQLite DB couldn't be closed:\n&quot; + e.getMessage());
<span class="nc" id="L305">    } catch (ClassNotFoundException e) {</span>
      // error! we don't have an org.sqlite.JDBC class!
      throw new ClassNotFoundException(
          &quot;ERROR: Could not load SQLite JDBC driver:\n&quot; + e.getMessage());
    }
  }

  /**
   * method to check if a table exists, returning a boolean indicating existence
   *
   * @param name the name of the table to be checked
   * @return boolean indicating existence of table
   * @throws ClassNotFoundException if could not load SQLite JDBC driver
   * @throws SQLException if could not successfully check if table exists
   *     &lt;p&gt;----------------------------------------------------------------------------- &lt;a
   *     href=&quot;https://stackoverflow.com/questions/27007931/java-check-table-existence-in-sqlite&quot;&gt;...&lt;/a&gt;
   *     -----------------------------------------------------------------------------
<span class="fc" id="L322">   */</span>
  public boolean tableExists(String name) throws ClassNotFoundException, SQLException {
    ResultSet rs = null;
    try {
<span class="fc" id="L326">      // check if we have an org.sqlite.JDBC class</span>
      // (throws ClassNotFoundException if no)
      this.checkForSqliteDriver();

<span class="fc bfc" id="L330" title="All 2 branches covered.">      // verify that we actually have a conn</span>
<span class="fc" id="L331">      // (throw exception if no)</span>
      if (this.connIsNull()) {
        throw new SQLException(&quot;this.conn == null&quot;);
      }
<span class="fc" id="L335"></span>
      // grab metadata of database
<span class="fc" id="L337">      DatabaseMetaData metadata = conn.getMetaData();</span>
      // get tables that match our table's name
<span class="fc" id="L339">      rs = metadata.getTables(null, null, name, null);</span>
      // move cursor to next row of result set - will return false if nothing there
<span class="fc" id="L341">      boolean exists = rs.next();</span>
      // close our statement!
<span class="fc" id="L343">      rs.close();</span>
<span class="fc" id="L344">      // return existence!</span>
      return exists;
    } catch (SQLException e) {
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">      // error checking if the table exists!</span>
<span class="nc" id="L348">      // close our statement!</span>
      if (rs != null) {
<span class="fc" id="L350">        rs.close();</span>
<span class="nc" id="L351">      }</span>
      throw new SQLException(
<span class="nc" id="L353">          &quot;ERROR: Couldn't check if table '&quot; + name + &quot;' exists:\n&quot; + e.getMessage());</span>
    } catch (ClassNotFoundException e) {
      // error! we don't have an org.sqlite.JDBC class!
      throw new ClassNotFoundException(
          &quot;ERROR: Could not load SQLite JDBC driver:\n&quot; + e.getMessage());
    }
  }

  /**
   * method to grab schema of a table, returning a string describing the schema
   *
   * @param name the name of the table to be checked
   * @return list representation of the schema as a string. each element is of the form &quot;[name]
   *     [type]&quot;, such as &quot;ID INTEGER&quot; or &quot;name VARCHAR(10)&quot;
   * @throws ClassNotFoundException if could not load SQLite JDBC driver
   * @throws SQLException if could not successfully check if table exists
   *     &lt;p&gt;----------------------------------------------------------------------------- &lt;a
   *     href=&quot;https://stackoverflow.com/questions/27007931/java-check-table-existence-in-sqlite&quot;&gt;...&lt;/a&gt;
<span class="fc" id="L371">   *     -----------------------------------------------------------------------------</span>
   */
  public ArrayList&lt;ColumnMetaData&gt; grabTableSchema(String name)
      throws ClassNotFoundException, SQLException {
<span class="fc" id="L375">    ResultSet rs = null;</span>
    try {
      // check if we have an org.sqlite.JDBC class
      // (throws ClassNotFoundException if no)
<span class="fc bfc" id="L379" title="All 2 branches covered.">      this.checkForSqliteDriver();</span>
<span class="fc" id="L380"></span>
      // verify that we actually have a conn
      // (throw exception if no)
      if (this.connIsNull()) {
<span class="fc bfc" id="L384" title="All 2 branches covered.">        throw new SQLException(&quot;this.conn == null&quot;);</span>
<span class="fc" id="L385">      }</span>

      // check if table exists
      if (!this.tableExists(name)) {
<span class="fc" id="L389">        throw new SQLException(&quot;table '&quot; + name + &quot;' does not exist!&quot;);</span>
      }
<span class="fc" id="L391"></span>
      // grab metadata of database
<span class="fc" id="L393">      DatabaseMetaData metadata = conn.getMetaData();</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">      // get columns of tables that match our table's name</span>
      rs = metadata.getColumns(null, null, name, null);
<span class="fc" id="L396">      // iterate through results for metadata query by tablename, adding to list</span>
<span class="fc" id="L397">      ArrayList&lt;ColumnMetaData&gt; schema = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L398">      while (rs.next()) {</span>
<span class="fc" id="L399">        // build record of metadata by grabbing from</span>
<span class="fc" id="L400">        String TABLE_NAME = rs.getString(&quot;TABLE_NAME&quot;);</span>
<span class="fc" id="L401">        String TABLE_SCHEM = rs.getString(&quot;TABLE_SCHEM&quot;);</span>
<span class="fc" id="L402">        String COLUMN_NAME = rs.getString(&quot;COLUMN_NAME&quot;);</span>
<span class="fc" id="L403">        String DATA_TYPE = rs.getString(&quot;DATA_TYPE&quot;);</span>
<span class="fc" id="L404">        String TYPE_NAME = rs.getString(&quot;TYPE_NAME&quot;);</span>
        int COLUMN_INDEX = rs.getInt(&quot;ORDINAL_POSITION&quot;);
<span class="fc" id="L406">        String NULLABLE = rs.getString(&quot;IS_NULLABLE&quot;);</span>
<span class="fc" id="L407">        String COLUMN_DEFAULT = rs.getString(&quot;COLUMN_DEF&quot;);</span>
        int VARCHAR_LEN = rs.getInt(&quot;COLUMN_SIZE&quot;);
        // build record and add to list
<span class="fc" id="L410">        schema.add(</span>
            new ColumnMetaData(
<span class="fc" id="L412">                TABLE_NAME,</span>
<span class="fc" id="L413">                TABLE_SCHEM,</span>
                COLUMN_NAME,
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">                DATA_TYPE,</span>
<span class="nc" id="L416">                TYPE_NAME,</span>
                COLUMN_INDEX,
                NULLABLE,
<span class="fc" id="L419">                COLUMN_DEFAULT,</span>
<span class="nc" id="L420">                VARCHAR_LEN));</span>
      }
<span class="nc" id="L422"></span>
      // close our statement!
      rs.close();
      // return schema!
      return schema;
    } catch (SQLException e) {
      // close our statement!
      if (rs != null) {
        rs.close();
      }
      // error checking if the table exists!
      throw new SQLException(
          &quot;ERROR: Couldn't grab schema of table '&quot; + name + &quot;':\n&quot; + e.getMessage());
    } catch (ClassNotFoundException e) {
      // error! we don't have an org.sqlite.JDBC class!
      throw new ClassNotFoundException(
          &quot;ERROR: Could not load SQLite JDBC driver:\n&quot; + e.getMessage());
    }
  }

  /**
   * Create a new table in the connected DB, returning boolean indicating success of creation. Fails
   * if no this.conn! -----------------------------------------------------------------------------
<span class="fc" id="L445">   * Source material: &lt;a href=&quot;https://www.sqlitetutorial.net/sqlite-java/create-table/&quot;&gt;...&lt;/a&gt;</span>
   * -----------------------------------------------------------------------------
   *
   * @param name the name of the table to be created
<span class="fc" id="L449">   * @param schema the schema of the table to be created EXAMPLE SCHEMA: String schema = &quot;id integer</span>
   *     PRIMARY KEY,\n&quot; + &quot;name text NOT NULL,\n&quot; + &quot;capacity real&quot;;
   * @return a boolean indicating success of table creation
   * @throws ClassNotFoundException if could not load SQLite JDBC driver
<span class="fc bfc" id="L453" title="All 2 branches covered.">   * @throws SQLException if could not successfully create new table</span>
<span class="fc" id="L454">   */</span>
  public boolean createNewTable(String name, String schema)
      throws ClassNotFoundException, SQLException {
    Statement statement = null;
<span class="fc bfc" id="L458" title="All 2 branches covered.">    try {</span>
      // check if we have an org.sqlite.JDBC class
<span class="fc" id="L460">      // (throws ClassNotFoundException if no)</span>
      this.checkForSqliteDriver();

      // verify that we actually have a conn
<span class="fc" id="L464">      // (throw exception if no)</span>
      if (this.connIsNull()) {
<span class="fc" id="L466">        throw new SQLException(&quot;this.conn == null&quot;);</span>
<span class="fc" id="L467">      }</span>

<span class="fc" id="L469">      // check if table already exists</span>
      if (tableExists(name)) {
        // if exists, throw error
<span class="fc" id="L472">        throw new SQLException(&quot;table '&quot; + name + &quot;' already exists!&quot;);</span>
<span class="fc" id="L473">      }</span>
<span class="fc" id="L474"></span>
      // make SQL statement for creating a new table
      String sqlStatment = &quot;CREATE TABLE &quot; + name + &quot; (&quot; + schema + &quot;);&quot;;
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">      // execute the statement!</span>
<span class="nc" id="L478">      statement = this.conn.createStatement();</span>
      statement.execute(sqlStatment);
<span class="fc" id="L480">      // close statement!</span>
<span class="nc" id="L481">      statement.close();</span>

<span class="nc" id="L483">      // return success!</span>
      System.out.println(&quot;Success! New table has been created&quot;);
      return true;
    } catch (SQLException e) {
      // error creating the new table!
      // close our statement if its open!
      if (statement != null) {
        statement.close();
      }
      throw new SQLException(&quot;ERROR: Couldn't create new table '&quot; + name + &quot;':\n&quot; + e.getMessage());
    } catch (ClassNotFoundException e) {
      // error! we don't have an org.sqlite.JDBC class!
      throw new ClassNotFoundException(
          &quot;ERROR: Could not load SQLite JDBC driver:\n&quot; + e.getMessage());
<span class="nc" id="L497">    }</span>
  }

  /**
<span class="nc" id="L501">   * Method for clearing out a table (all elements, all rows)</span>
   *
   * @param name the name of the table to clear
   * @return a boolean indicating success of clearing of DB
<span class="nc bnc" id="L505" title="All 2 branches missed.">   * @throws ClassNotFoundException if could not load SQLite JDBC driver</span>
<span class="nc" id="L506">   * @throws SQLException if could not successfully clear table</span>
   */
  public boolean clearTable(String name) throws ClassNotFoundException, SQLException {
    Statement statement = null;
<span class="nc bnc" id="L510" title="All 2 branches missed.">    try {</span>
      // check if we have an org.sqlite.JDBC class
<span class="nc" id="L512">      // (throws ClassNotFoundException if no)</span>
      this.checkForSqliteDriver();

      // verify that we actually have a conn
<span class="nc" id="L516">      // (throw exception if no)</span>
      if (this.connIsNull()) {
<span class="nc" id="L518">        throw new SQLException(&quot;this.conn == null&quot;);</span>
<span class="nc" id="L519">      }</span>

<span class="nc" id="L521">      // check if table doesn't exist</span>
      if (!tableExists(name)) {
        // if exists, throw error
<span class="nc" id="L524">        throw new SQLException(&quot;table '&quot; + name + &quot;' does not exist!&quot;);</span>
<span class="nc" id="L525">      }</span>
<span class="nc" id="L526"></span>
      // make SQL statement for clearing a table
      String sqlStatment = &quot;DELETE FROM &quot; + name + &quot;;&quot;;
<span class="nc bnc" id="L529" title="All 2 branches missed.">      // execute the statement!</span>
<span class="nc" id="L530">      statement = this.conn.createStatement();</span>
      statement.execute(sqlStatment);
<span class="nc" id="L532">      // close statement!</span>
<span class="nc" id="L533">      statement.close();</span>

<span class="nc" id="L535">      // return success!</span>
      System.out.println(&quot;Success! Table has been cleared in connected database&quot;);
      return true;
    } catch (SQLException e) {
      // error clearing the table!
      // close our statement if its open!
      if (statement != null) {
        statement.close();
      }
      throw new SQLException(&quot;ERROR: Couldn't clear table '&quot; + name + &quot;':\n&quot; + e.getMessage());
    } catch (ClassNotFoundException e) {
      // error! we don't have an org.sqlite.JDBC class!
      throw new ClassNotFoundException(
<span class="fc" id="L548">          &quot;ERROR: Could not load SQLite JDBC driver:\n&quot; + e.getMessage());</span>
    }
  }

<span class="fc" id="L552">  /**</span>
   * Method for dropping a table (delete table itself).
   *
   * @param name the name of the table to drop
<span class="fc bfc" id="L556" title="All 2 branches covered.">   * @return a boolean indicating if table was deleted successfully</span>
<span class="fc" id="L557">   * @throws ClassNotFoundException if could not load SQLite JDBC driver</span>
   * @throws SQLException if could not successfully drop table
   */
  public boolean dropTable(String name) throws ClassNotFoundException, SQLException {
<span class="fc bfc" id="L561" title="All 2 branches covered.">    Statement statement = null;</span>
    try {
<span class="fc" id="L563">      // check if we have an org.sqlite.JDBC class</span>
      // (throws ClassNotFoundException if no)
      this.checkForSqliteDriver();

<span class="fc" id="L567">      // verify that we actually have a conn</span>
      // (throw exception if no)
<span class="fc" id="L569">      if (this.connIsNull()) {</span>
<span class="fc" id="L570">        throw new SQLException(&quot;this.conn == null&quot;);</span>
      }
<span class="fc" id="L572"></span>
      // check if table doesn't exist
      if (!tableExists(name)) {
<span class="fc" id="L575">        // if exists, throw error</span>
<span class="fc" id="L576">        throw new SQLException(&quot;table '&quot; + name + &quot;' does not exist!&quot;);</span>
<span class="fc" id="L577">      }</span>

      // make SQL udpate for dropping a table
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">      String sqlUpdate = &quot;DROP TABLE &quot; + name + &quot;;&quot;;</span>
<span class="nc" id="L581">      // execute the statement!</span>
      statement = this.conn.createStatement();
<span class="fc" id="L583">      statement.executeUpdate(sqlUpdate);</span>
<span class="nc" id="L584">      // close statement!</span>
      statement.close();
<span class="nc" id="L586"></span>
      // return success!
      System.out.println(&quot;Success! Table has been dropped in connected database&quot;);
      return true;
    } catch (SQLException e) {
      // error dropping the table!
      // close our statement if its open!
      if (statement != null) {
        statement.close();
      }
      throw new SQLException(&quot;ERROR: Couldn't drop table '&quot; + name + &quot;':\n&quot; + e.getMessage());
    } catch (ClassNotFoundException e) {
      // error! we don't have an org.sqlite.JDBC class!
      throw new ClassNotFoundException(
          &quot;ERROR: Could not load SQLite JDBC driver:\n&quot; + e.getMessage());
    }
  }

  //  NOTE: THIS METHOD DID NOT SEEM USEFUL, SO I COMMENTED IT OUT
  //
  //  /**
  //   * Method for clearing out a DB (all elements, all tables, all rows)
  //   *
  //   * @return a boolean indicating success of clearing of table
  //   * @throws ClassNotFoundException if could not load SQLite JDBC driver
  //   * @throws SQLException if could not successfully clear SQLiteDB
  //   *
  //   */
  //  public boolean clearDB() throws ClassNotFoundException, SQLException {
  //    Statement statement = null;
  //    try {
  //      // check if we have an org.sqlite.JDBC class
  //      // (throws ClassNotFoundException if no)
  //      this.checkForSqliteDriver();
  //
  //      // verify that we actually have a conn
  //      // (throw exception if no)
  //      if (this.connIsNull()) {
  //        throw new SQLException(&quot;this.conn == null&quot;);
  //      }
  //
  //      // make SQL query for selecting all tables
  //      String sqlQuery = &quot;SELECT name FROM sqlite_master WHERE type='table'&quot;;
  //      // execute the statement!
  //      statement = this.conn.createStatement();
  //      ResultSet result = statement.executeQuery(sqlQuery);
  //      // close statement!
  //      statement.close();
  //
  //      // Generate a series of &quot;DROP TABLE&quot; queries for each table name
  //      while (result.next()) {
  //        // drop tables!
  //        String name = result.getString(&quot;name&quot;);
  //        if (!this.dropTable(name)) {
  //          // if drop table failed, report failure
  //          throw new SQLException(&quot;ERROR: Couldn't clear SQLiteDB&quot;);
  //        }
  //      }
  //
  //      // return success!
  //      System.out.println(&quot;Success! All tables have been deleted in database&quot;);
  //      return true;
  //    } catch (SQLException e) {
  //      // error clear the DB!
  //      // close our statement if its open!
  //      if (statement != null) {
  //        statement.close();
  //      }      throw new SQLException(&quot;ERROR: Couldn't clear SQLiteDB:\n&quot; + e.getMessage());
  //    } catch (ClassNotFoundException e) {
  //      // error! we don't have an org.sqlite.JDBC class!
  //      throw new ClassNotFoundException(&quot;ERROR: Could not load SQLite JDBC driver:\n&quot; +
  // e.getMessage());
  //    }
<span class="fc" id="L659">  //  }</span>

  /**
   * Method for deleting a DB (the file itself)
<span class="fc bfc" id="L663" title="All 2 branches covered.">   *</span>
<span class="fc" id="L664">   * @return a boolean indicating success of deleting this DB!</span>
   * @throws ClassNotFoundException if could not load SQLite JDBC driver
   * @throws SQLException if could not successfully delete SQLiteDB
<span class="fc" id="L667">   */</span>
  public boolean deleteDB() throws ClassNotFoundException, SQLException {
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">    try {</span>
<span class="nc" id="L670">      // check if we have an org.sqlite.JDBC class</span>
      // (throws ClassNotFoundException if no)
      this.checkForSqliteDriver();

<span class="fc" id="L674">      // verify that we actually have a conn</span>
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">      // (throw exception if no)</span>
<span class="nc" id="L676">      if (this.connIsNull()) {</span>
        throw new SQLException(&quot;this.conn == null&quot;);
      }

<span class="pc bpc" id="L680" title="1 of 2 branches missed.">      String oldPath = this.relativeFilepath;</span>
<span class="nc" id="L681">      // close conn to our file</span>
      if (!this.closeDB()) {
        throw new SQLException(&quot;ERROR: Couldn't close this.conn&quot;);
      }
<span class="fc" id="L685"></span>
<span class="fc" id="L686">      // grab our file, check if it exists</span>
      File f = new File(oldPath);
      if (!f.exists()) {
<span class="fc" id="L689">        throw new SQLException(</span>
<span class="fc" id="L690">            &quot;File '&quot;</span>
<span class="fc" id="L691">                + System.getProperty(&quot;user.dir&quot;)</span>
                + &quot;/&quot;
<span class="fc" id="L693">                + this.relativeFilepath</span>
<span class="nc" id="L694">                + &quot;' doesn't exist&quot;);</span>
      }
<span class="nc" id="L696"></span>
      // try to delete our file
      if (!f.delete()) {
        throw new SQLException(
            &quot;File.delete() failed on '&quot;
                + System.getProperty(&quot;user.dir&quot;)
                + &quot;/&quot;
                + this.relativeFilepath
                + &quot;'&quot;);
      }

      // set conn and filepath
      this.conn = null;
      this.relativeFilepath = null;
<span class="fc" id="L710"></span>
      // return success!
      System.out.println(&quot;Success! Database has been deleted&quot;);
      return true;
<span class="fc" id="L714">    } catch (SQLException e) {</span>
      // error deleting the DB!
      throw new SQLException(&quot;ERROR: Couldn't delete SQLiteDB:\n&quot; + e.getMessage());
    } catch (ClassNotFoundException e) {
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">      // error! we don't have an org.sqlite.JDBC class!</span>
<span class="nc" id="L719">      throw new ClassNotFoundException(</span>
          &quot;ERROR: Could not load SQLite JDBC driver:\n&quot; + e.getMessage());
    }
  }
<span class="fc" id="L723">  /**</span>
<span class="fc" id="L724">   * Function for executing an SQL Query! Very open-ended for maximum flexibility :) NOTE: DON'T</span>
   * FORGET TO CLOSE THE RETURNED ResultSet! You will encounter headaches later if you forget...
   *
<span class="fc" id="L727">   * @param sqlQuery the query to be executed</span>
<span class="fc" id="L728">   * @return a ResultSet with the results of the query</span>
<span class="fc" id="L729">   * @throws ClassNotFoundException if could not load SQLite JDBC driver</span>
   * @throws SQLException if could not successfully execute SQLQuery
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">   */</span>
<span class="fc" id="L732">  public ResultSet executeSQLQuery(String sqlQuery) throws ClassNotFoundException, SQLException {</span>
    Statement statement = null;
    try {
<span class="fc" id="L735">      // check if we have an org.sqlite.JDBC class</span>
<span class="nc" id="L736">      // (throws ClassNotFoundException if no)</span>
      this.checkForSqliteDriver();
<span class="nc" id="L738"></span>
      // verify that we actually have a conn
      // (throw exception if no)
      if (this.connIsNull()) {
        throw new SQLException(&quot;this.conn == null&quot;);
      }

      // execute the statement!
      statement = this.conn.createStatement();
      ResultSet result = statement.executeQuery(sqlQuery);

      // return success!
      System.out.println(&quot;Success! SQL Query has been executed in connected database&quot;);
      return result;
    } catch (SQLException e) {
      // close our statement if its open!
      if (statement != null) {
<span class="fc" id="L755">        statement.close();</span>
      }
      // error executing the SQLQuery!
      throw new SQLException(
<span class="fc" id="L759">          &quot;ERROR: Couldn't execute SQLQuery\n'&quot; + sqlQuery + &quot;':\n&quot; + e.getMessage());</span>
    } catch (ClassNotFoundException e) {
      // error! we don't have an org.sqlite.JDBC class!
      throw new ClassNotFoundException(
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">          &quot;ERROR: Could not load SQLite JDBC driver:\n&quot; + e.getMessage());</span>
<span class="nc" id="L764">    }</span>
  }

  /**
<span class="fc" id="L768">   * Function for executing an SQL Statement THAT RETURNS A RESULT SET OR UPDATES SOME ROWS! Very</span>
<span class="fc" id="L769">   * open-ended for maximum flexibility :)</span>
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">   *</span>
   * @param sqlStatement the statement to be executed
<span class="nc" id="L772">   * @return a boolean and Statement containing the results. The boolean indicates if there is a</span>
   *     result set with items in it. If false, there are no items, and/or the return value of the
   *     statement isn't actually a ResultSet, but an updateCount. NOTE: on INSERT, bool = false &amp;&amp;
<span class="fc" id="L775">   *     updateCount &gt; 0</span>
   * @throws ClassNotFoundException if could not load SQLite JDBC driver
   * @throws SQLException if could not successfully execute SQLStatement
<span class="fc" id="L778">   */</span>
<span class="fc" id="L779">  public Pair&lt;Boolean, Statement&gt; executeSQLStatement(String sqlStatement)</span>
      throws ClassNotFoundException, SQLException {
    Statement statement = null;
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">    try {</span>
<span class="fc" id="L783">      // check if we have an org.sqlite.JDBC class</span>
      // (throws ClassNotFoundException if no)
<span class="fc" id="L785">      this.checkForSqliteDriver();</span>
<span class="nc" id="L786"></span>
      // verify that we actually have a conn
<span class="nc" id="L788">      // (throw exception if no)</span>
      if (this.connIsNull()) {
        throw new SQLException(&quot;this.conn == null&quot;);
      }

      // execute the statement!
      statement = this.conn.createStatement();
      boolean ret = statement.execute(sqlStatement);
      if (ret) {
        // ResultSet
        System.out.println(
            &quot;Success! SQL Statement has been executed in connected database - ResultSet returned from statement&quot;);
      }
      // no items or updateCount
      System.out.println(
          &quot;Success! SQL Statement has been executed in connected database - UpdateCount returned from statement, or no items in ResultSet&quot;);

      // return success!
      return new Pair&lt;Boolean, Statement&gt;(ret, statement);
    } catch (SQLException e) {
      // error executing the SQLStatement!
      // close our statement if its open!
      if (statement != null) {
<span class="pc" id="L811">        statement.close();</span>
      }
      throw new SQLException(
          &quot;ERROR: Couldn't execute SQLStatement\n'&quot; + sqlStatement + &quot;':\n&quot; + e.getMessage());
    } catch (ClassNotFoundException e) {
      // error! we don't have an org.sqlite.JDBC class!
      throw new ClassNotFoundException(
          &quot;ERROR: Could not load SQLite JDBC driver:\n&quot; + e.getMessage());
    }
  }

  /**
<span class="nc bnc" id="L823" title="All 2 branches missed.">   * Record to hold metadata of a column from conn.getMetaData.getTables() The record's information</span>
   * is populated fromDatabaseMetaData.java, line 1573 and onwards
<span class="nc bnc" id="L825" title="All 4 branches missed.">   *</span>
   * @param TABLE_NAME name of table
<span class="nc" id="L827">   * @param TABLE_SCHEM schema of table??? (may be null)</span>
<span class="nc bnc" id="L828" title="All 18 branches missed.">   * @param COLUMN_NAME name of column</span>
   * @param DATA_TYPE type of column
   * @param TYPE_NAME type name of column???
   * @param COLUMN_INDEX index of column (starting at 1)
   * @param NULLABLE is column nullable
   * @param COLUMN_DEFAULT default value for column (may be null)
   * @param VARCHAR_LEN if varchar, length of varchar &quot;Note that numeric arguments in parentheses
   *     that following the type name (ex: &quot;VARCHAR(255)&quot;) are ignored by SQLite. SQLite does not
   *     impose any length restrictions (other than the large global SQLITE_MAX_LENGTH limit) on the
<span class="nc" id="L837">   *     length of strings, BLOBs or numeric values.&quot; src = &lt;a</span>
   *     href=&quot;https://stackoverflow.com/questions/35413956/trying-to-get-the-column-size-of-a-column-using-jdbc-metadata&quot;&gt;...&lt;/a&gt;
   */
  public record ColumnMetaData(
      String TABLE_NAME,
      String TABLE_SCHEM,
      String COLUMN_NAME,
      String DATA_TYPE,
      String TYPE_NAME,
      int COLUMN_INDEX,
      String NULLABLE,
      String COLUMN_DEFAULT,
      int VARCHAR_LEN) {
    /**
     * equality checker for this record!
     *
     * @param that the object we want to compare this to for equality (generated by IntelliJ)
     * @return boolean indicating equality of this and that
     */
    @Override
    public boolean equals(Object that) {
      // check equality methodically!
      if (this == that) return true;
      // if that == null or classes don't match...
      if (that == null || this.getClass() != that.getClass()) return false;
      // cast that as ColumnMetaData
      ColumnMetaData thatCast = (ColumnMetaData) that;
      return COLUMN_INDEX == thatCast.COLUMN_INDEX
          &amp;&amp; VARCHAR_LEN == thatCast.VARCHAR_LEN
          &amp;&amp; TABLE_NAME.equals(thatCast.TABLE_NAME)
          &amp;&amp; Objects.equals(TABLE_SCHEM, thatCast.TABLE_SCHEM)
          &amp;&amp; COLUMN_NAME.equals(thatCast.COLUMN_NAME)
          &amp;&amp; DATA_TYPE.equals(thatCast.DATA_TYPE)
          &amp;&amp; Objects.equals(TYPE_NAME, thatCast.TYPE_NAME)
          &amp;&amp; NULLABLE.equals(thatCast.NULLABLE)
          &amp;&amp; Objects.equals(COLUMN_DEFAULT, thatCast.COLUMN_DEFAULT);
    }

    /**
     * Hasher for this record!
     *
     * @return an int that is the hashcode for this object
     */
    @Override
    public int hashCode() {
      return Objects.hash(
          TABLE_NAME,
          TABLE_SCHEM,
          COLUMN_NAME,
          DATA_TYPE,
          TYPE_NAME,
          COLUMN_INDEX,
          NULLABLE,
          COLUMN_DEFAULT,
          VARCHAR_LEN);
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>